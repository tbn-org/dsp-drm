"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = void 0;
const console_1 = require("console");
const path = require("path");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const directories_1 = require("../../util/directories");
const aws_auth_1 = require("../aws-auth");
const deploy_bootstrap_1 = require("./deploy-bootstrap");
const legacy_template_1 = require("./legacy-template");
class Bootstrapper {
    constructor(source) {
        this.source = source;
    }
    bootstrapEnvironment(environment, sdkProvider, options = {}) {
        switch (this.source.source) {
            case 'legacy':
                return this.legacyBootstrap(environment, sdkProvider, options);
            case 'default':
                return this.modernBootstrap(environment, sdkProvider, options);
            case 'custom':
                return this.customBootstrap(environment, sdkProvider, options);
        }
    }
    async showTemplate(json) {
        const template = await this.loadTemplate();
        process.stdout.write(`${serialize_1.serializeStructure(template, json)}\n`);
    }
    /**
     * Deploy legacy bootstrap stack
     *
     */
    async legacyBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        if (params.trustedAccounts?.length) {
            throw new Error('--trust can only be passed for the modern bootstrap experience.');
        }
        if (params.cloudFormationExecutionPolicies?.length) {
            throw new Error('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');
        }
        if (params.createCustomerMasterKey !== undefined) {
            throw new Error('--bootstrap-customer-key can only be passed for the modern bootstrap experience.');
        }
        if (params.qualifier) {
            throw new Error('--qualifier can only be passed for the modern bootstrap experience.');
        }
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        return current.update(await this.loadTemplate(params), {}, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    /**
     * Deploy CI/CD-ready bootstrap stack from template
     *
     */
    async modernBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        const bootstrapTemplate = await this.loadTemplate();
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        const partition = await current.partition();
        if (params.createCustomerMasterKey !== undefined && params.kmsKeyId) {
            throw new Error('You cannot pass \'--bootstrap-kms-key-id\' and \'--bootstrap-customer-key\' together. Specify one or the other');
        }
        // If people re-bootstrap, existing parameter values are reused so that people don't accidentally change the configuration
        // on their bootstrap stack (this happens automatically in deployStack). However, to do proper validation on the
        // combined arguments (such that if --trust has been given, --cloudformation-execution-policies is necessary as well)
        // we need to take this parameter reuse into account.
        //
        // Ideally we'd do this inside the template, but the `Rules` section of CFN
        // templates doesn't seem to be able to express the conditions that we need
        // (can't use Fn::Join or reference Conditions) so we do it here instead.
        const trustedAccounts = params.trustedAccounts ?? splitCfnArray(current.parameters.TrustedAccounts);
        console_1.info(`Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(', ') : '(none)'}`);
        const trustedAccountsForLookup = params.trustedAccountsForLookup ?? splitCfnArray(current.parameters.TrustedAccountsForLookup);
        console_1.info(`Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(', ') : '(none)'}`);
        const cloudFormationExecutionPolicies = params.cloudFormationExecutionPolicies ?? splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
        if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
            // For self-trust it's okay to default to AdministratorAccess, and it improves the usability of bootstrapping a lot.
            //
            // We don't actually make the implicitly policy a physical parameter. The template will infer it instead,
            // we simply do the UI advertising that behavior here.
            //
            // If we DID make it an explicit parameter, we wouldn't be able to tell the difference between whether
            // we inferred it or whether the user told us, and the sequence:
            //
            // $ cdk bootstrap
            // $ cdk bootstrap --trust 1234
            //
            // Would leave AdministratorAccess policies with a trust relationship, without the user explicitly
            // approving the trust policy.
            const implicitPolicy = `arn:${partition}:iam::aws:policy/AdministratorAccess`;
            logging_1.warning(`Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`);
        }
        else if (cloudFormationExecutionPolicies.length === 0) {
            throw new Error('Please pass \'--cloudformation-execution-policies\' when using \'--trust\' to specify deployment permissions. Try a managed policy of the form \'arn:aws:iam::aws:policy/<PolicyName>\'.');
        }
        else {
            // Remind people what the current settings are
            console_1.info(`Execution policies: ${cloudFormationExecutionPolicies.join(', ')}`);
        }
        // * If an ARN is given, that ARN. Otherwise:
        //   * '-' if customerKey = false
        //   * '' if customerKey = true
        //   * if customerKey is also not given
        //     * undefined if we already had a value in place (reusing what we had)
        //     * '-' if this is the first time we're deploying this stack (or upgrading from old to new bootstrap)
        const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
        const kmsKeyId = params.kmsKeyId ??
            (params.createCustomerMasterKey === true ? CREATE_NEW_KEY :
                params.createCustomerMasterKey === false || currentKmsKeyId === undefined ? USE_AWS_MANAGED_KEY : undefined);
        /* A permissions boundary can be provided via:
        *    - the flag indicating the example one should be used
        *    - the name indicating the custom permissions boundary to be used
        * Re-bootstrapping will NOT be blocked by either tightening or relaxing the permissions' boundary.
        */
        const currentPermissionsBoundary = current.parameters.InputPermissionsBoundary;
        const inputPolicyName = params.examplePermissionsBoundary ? CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY : params.customPermissionsBoundary;
        let policyName;
        if (inputPolicyName) {
            // If the example policy is not already in place, it must be created.
            const sdk = (await sdkProvider.forEnvironment(environment, aws_auth_1.Mode.ForWriting)).sdk;
            policyName = await this.getPolicyName(environment, sdk, inputPolicyName, partition, params);
        }
        if (currentPermissionsBoundary !== policyName) {
            logging_1.warning(`Switching from ${currentPermissionsBoundary} to ${policyName} as permissions boundary`);
        }
        return current.update(bootstrapTemplate, {
            FileAssetsBucketName: params.bucketName,
            FileAssetsBucketKmsKeyId: kmsKeyId,
            // Empty array becomes empty string
            TrustedAccounts: trustedAccounts.join(','),
            TrustedAccountsForLookup: trustedAccountsForLookup.join(','),
            CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(','),
            Qualifier: params.qualifier,
            PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === undefined ? 'true' : 'false',
            InputPermissionsBoundary: policyName,
        }, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    async getPolicyName(environment, sdk, permissionsBoundary, partition, params) {
        if (permissionsBoundary !== CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY) {
            this.validatePolicyName(permissionsBoundary);
            return Promise.resolve(permissionsBoundary);
        }
        // if no Qualifier is supplied, resort to the default one
        const arn = await this.getExamplePermissionsBoundary(params.qualifier ?? 'hnb659fds', partition, environment.account, sdk);
        const policyName = arn.split('/').pop();
        if (!policyName) {
            throw new Error('Could not retrieve the example permission boundary!');
        }
        return Promise.resolve(policyName);
    }
    async getExamplePermissionsBoundary(qualifier, partition, account, sdk) {
        const iam = sdk.iam();
        let policyName = `cdk-${qualifier}-permissions-boundary`;
        const arn = `arn:${partition}:iam::${account}:policy/${policyName}`;
        try {
            let getPolicyResp = await iam.getPolicy({ PolicyArn: arn }).promise();
            if (getPolicyResp.Policy) {
                return arn;
            }
        }
        catch (e) {
            // https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetPolicy.html#API_GetPolicy_Errors
            if (e.name === 'NoSuchEntity') {
                //noop, proceed with creating the policy
            }
            else {
                throw e;
            }
        }
        const policyDoc = {
            Version: '2012-10-17',
            Statement: [
                {
                    Action: ['*'],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'ExplicitAllowAll',
                },
                {
                    Condition: {
                        StringEquals: {
                            'iam:PermissionsBoundary': `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                        },
                    },
                    Action: [
                        'iam:CreateUser',
                        'iam:CreateRole',
                        'iam:PutRolePermissionsBoundary',
                        'iam:PutUserPermissionsBoundary',
                    ],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'DenyAccessIfRequiredPermBoundaryIsNotBeingApplied',
                },
                {
                    Action: [
                        'iam:CreatePolicyVersion',
                        'iam:DeletePolicy',
                        'iam:DeletePolicyVersion',
                        'iam:SetDefaultPolicyVersion',
                    ],
                    Resource: `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                    Effect: 'Deny',
                    Sid: 'DenyPermBoundaryIAMPolicyAlteration',
                },
                {
                    Action: [
                        'iam:DeleteUserPermissionsBoundary',
                        'iam:DeleteRolePermissionsBoundary',
                    ],
                    Resource: '*',
                    Effect: 'Deny',
                    Sid: 'DenyRemovalOfPermBoundaryFromAnyUserOrRole',
                },
            ],
        };
        const request = {
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDoc),
        };
        const createPolicyResponse = await iam.createPolicy(request).promise();
        if (createPolicyResponse.Policy?.Arn) {
            return createPolicyResponse.Policy.Arn;
        }
        else {
            throw new Error(`Could not retrieve the example permission boundary ${arn}!`);
        }
    }
    validatePolicyName(permissionsBoundary) {
        // https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html
        const regexp = /[\w+=,.@-]+/;
        const matches = regexp.exec(permissionsBoundary);
        if (!(matches && matches.length === 1 && matches[0] === permissionsBoundary)) {
            throw new Error(`The permissions boundary name ${permissionsBoundary} does not match the IAM conventions.`);
        }
    }
    async customBootstrap(environment, sdkProvider, options = {}) {
        // Look at the template, decide whether it's most likely a legacy or modern bootstrap
        // template, and use the right bootstrapper for that.
        const version = deploy_bootstrap_1.bootstrapVersionFromTemplate(await this.loadTemplate());
        if (version === 0) {
            return this.legacyBootstrap(environment, sdkProvider, options);
        }
        else {
            return this.modernBootstrap(environment, sdkProvider, options);
        }
    }
    async loadTemplate(params = {}) {
        switch (this.source.source) {
            case 'custom':
                return serialize_1.loadStructuredFile(this.source.templateFile);
            case 'default':
                return serialize_1.loadStructuredFile(path.join(directories_1.rootDir(), 'lib', 'api', 'bootstrap', 'bootstrap-template.yaml'));
            case 'legacy':
                return legacy_template_1.legacyBootstrapTemplate(params);
        }
    }
}
exports.Bootstrapper = Bootstrapper;
/**
 * Magic parameter value that will cause the bootstrap-template.yml to NOT create a CMK but use the default key
 */
const USE_AWS_MANAGED_KEY = 'AWS_MANAGED_KEY';
/**
 * Magic parameter value that will cause the bootstrap-template.yml to create a CMK
 */
const CREATE_NEW_KEY = '';
/**
 * Parameter value indicating the use of the default, CDK provided permissions boundary for bootstrap-template.yml
 */
const CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY = 'CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY';
/**
 * Split an array-like CloudFormation parameter on ,
 *
 * An empty string is the empty array (instead of `['']`).
 */
function splitCfnArray(xs) {
    if (xs === '' || xs === undefined) {
        return [];
    }
    return xs.split(',');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLWVudmlyb25tZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwLWVudmlyb25tZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUErQjtBQUMvQiw2QkFBNkI7QUFFN0IsMkNBQXdDO0FBQ3hDLCtDQUF5RTtBQUN6RSx3REFBaUQ7QUFDakQsMENBQXNEO0FBR3RELHlEQUFrRjtBQUNsRix1REFBNEQ7QUFVNUQsTUFBYSxZQUFZO0lBQ3ZCLFlBQTZCLE1BQXVCO1FBQXZCLFdBQU0sR0FBTixNQUFNLENBQWlCO0lBQ3BELENBQUM7SUFFTSxvQkFBb0IsQ0FBQyxXQUE4QixFQUFFLFdBQXdCLEVBQUUsVUFBdUMsRUFBRTtRQUM3SCxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQzFCLEtBQUssUUFBUTtnQkFDWCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNqRSxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDakUsS0FBSyxRQUFRO2dCQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2xFO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBYTtRQUNyQyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMzQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLDhCQUFrQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEOzs7T0FHRztJQUNLLEtBQUssQ0FBQyxlQUFlLENBQUMsV0FBOEIsRUFBRSxXQUF3QixFQUFFLFVBQXVD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QyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNoRTthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDaEU7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLFlBQVksQ0FBQyxTQUFrQyxFQUFFO1FBQzdELFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDMUIsS0FBSyxRQUFRO2dCQUNYLE9BQU8sOEJBQWtCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN0RCxLQUFLLFNBQVM7Z0JBQ1osT0FBTyw4QkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7WUFDeEcsS0FBSyxRQUFRO2dCQUNYLE9BQU8seUNBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDMUM7SUFDSCxDQUFDO0NBQ0Y7QUE1UkQsb0NBNFJDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLG1CQUFtQixHQUFHLGlCQUFpQixDQUFDO0FBRTlDOztHQUVHO0FBQ0gsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQzFCOztHQUVHO0FBQ0gsTUFBTSxrQ0FBa0MsR0FBRyxvQ0FBb0MsQ0FBQztBQUVoRjs7OztHQUlHO0FBQ0gsU0FBUyxhQUFhLENBQUMsRUFBc0I7SUFDM0MsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxTQUFTLEVBQUU7UUFBRSxPQUFPLEVBQUUsQ0FBQztLQUFFO0lBQ2pELE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5mbyB9IGZyb20gJ2NvbnNvbGUnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBsb2FkU3RydWN0dXJlZEZpbGUsIHNlcmlhbGl6ZVN0cnVjdHVyZSB9IGZyb20gJy4uLy4uL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyByb290RGlyIH0gZnJvbSAnLi4vLi4vdXRpbC9kaXJlY3Rvcmllcyc7XG5pbXBvcnQgeyBJU0RLLCBNb2RlLCBTZGtQcm92aWRlciB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi4vZGVwbG95LXN0YWNrJztcbmltcG9ydCB7IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucywgQm9vdHN0cmFwcGluZ1BhcmFtZXRlcnMgfSBmcm9tICcuL2Jvb3RzdHJhcC1wcm9wcyc7XG5pbXBvcnQgeyBCb290c3RyYXBTdGFjaywgYm9vdHN0cmFwVmVyc2lvbkZyb21UZW1wbGF0ZSB9IGZyb20gJy4vZGVwbG95LWJvb3RzdHJhcCc7XG5pbXBvcnQgeyBsZWdhY3lCb290c3RyYXBUZW1wbGF0ZSB9IGZyb20gJy4vbGVnYWN5LXRlbXBsYXRlJztcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5leHBvcnQgdHlwZSBCb290c3RyYXBTb3VyY2UgPVxuICB7IHNvdXJjZTogJ2xlZ2FjeScgfVxuICB8IHsgc291cmNlOiAnZGVmYXVsdCcgfVxuICB8IHsgc291cmNlOiAnY3VzdG9tJzsgdGVtcGxhdGVGaWxlOiBzdHJpbmcgfTtcblxuXG5leHBvcnQgY2xhc3MgQm9vdHN0cmFwcGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzb3VyY2U6IEJvb3RzdHJhcFNvdXJjZSkge1xuICB9XG5cbiAgcHVibGljIGJvb3RzdHJhcEVudmlyb25tZW50KGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLCBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBzd2l0Y2ggKHRoaXMuc291cmNlLnNvdXJjZSkge1xuICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnYWN5Qm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZXJuQm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2hvd1RlbXBsYXRlKGpzb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IHRoaXMubG9hZFRlbXBsYXRlKCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7c2VyaWFsaXplU3RydWN0dXJlKHRlbXBsYXRlLCBqc29uKX1cXG5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgbGVnYWN5IGJvb3RzdHJhcCBzdGFja1xuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsZWdhY3lCb290c3RyYXAoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1ldGVycyA/PyB7fTtcblxuICAgIGlmIChwYXJhbXMudHJ1c3RlZEFjY291bnRzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS10cnVzdCBjYW4gb25seSBiZSBwYXNzZWQgZm9yIHRoZSBtb2Rlcm4gYm9vdHN0cmFwIGV4cGVyaWVuY2UuJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcz8ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJy0tYm9vdHN0cmFwLWN1c3RvbWVyLWtleSBjYW4gb25seSBiZSBwYXNzZWQgZm9yIHRoZSBtb2Rlcm4gYm9vdHN0cmFwIGV4cGVyaWVuY2UuJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMucXVhbGlmaWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJy0tcXVhbGlmaWVyIGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50ID0gYXdhaXQgQm9vdHN0cmFwU3RhY2subG9va3VwKHNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudCwgb3B0aW9ucy50b29sa2l0U3RhY2tOYW1lKTtcbiAgICByZXR1cm4gY3VycmVudC51cGRhdGUoYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUocGFyYW1zKSwge30sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0ZXJtaW5hdGlvblByb3RlY3Rpb246IG9wdGlvbnMudGVybWluYXRpb25Qcm90ZWN0aW9uID8/IGN1cnJlbnQudGVybWluYXRpb25Qcm90ZWN0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBDSS9DRC1yZWFkeSBib290c3RyYXAgc3RhY2sgZnJvbSB0ZW1wbGF0ZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtb2Rlcm5Cb290c3RyYXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVwbG95U3RhY2tSZXN1bHQ+IHtcblxuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1ldGVycyA/PyB7fTtcblxuICAgIGNvbnN0IGJvb3RzdHJhcFRlbXBsYXRlID0gYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKTtcblxuICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBCb290c3RyYXBTdGFjay5sb29rdXAoc2RrUHJvdmlkZXIsIGVudmlyb25tZW50LCBvcHRpb25zLnRvb2xraXRTdGFja05hbWUpO1xuICAgIGNvbnN0IHBhcnRpdGlvbiA9IGF3YWl0IGN1cnJlbnQucGFydGl0aW9uKCk7XG5cbiAgICBpZiAocGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zLmttc0tleUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcGFzcyBcXCctLWJvb3RzdHJhcC1rbXMta2V5LWlkXFwnIGFuZCBcXCctLWJvb3RzdHJhcC1jdXN0b21lci1rZXlcXCcgdG9nZXRoZXIuIFNwZWNpZnkgb25lIG9yIHRoZSBvdGhlcicpO1xuICAgIH1cblxuICAgIC8vIElmIHBlb3BsZSByZS1ib290c3RyYXAsIGV4aXN0aW5nIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHJldXNlZCBzbyB0aGF0IHBlb3BsZSBkb24ndCBhY2NpZGVudGFsbHkgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb24gdGhlaXIgYm9vdHN0cmFwIHN0YWNrICh0aGlzIGhhcHBlbnMgYXV0b21hdGljYWxseSBpbiBkZXBsb3lTdGFjaykuIEhvd2V2ZXIsIHRvIGRvIHByb3BlciB2YWxpZGF0aW9uIG9uIHRoZVxuICAgIC8vIGNvbWJpbmVkIGFyZ3VtZW50cyAoc3VjaCB0aGF0IGlmIC0tdHJ1c3QgaGFzIGJlZW4gZ2l2ZW4sIC0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGlzIG5lY2Vzc2FyeSBhcyB3ZWxsKVxuICAgIC8vIHdlIG5lZWQgdG8gdGFrZSB0aGlzIHBhcmFtZXRlciByZXVzZSBpbnRvIGFjY291bnQuXG4gICAgLy9cbiAgICAvLyBJZGVhbGx5IHdlJ2QgZG8gdGhpcyBpbnNpZGUgdGhlIHRlbXBsYXRlLCBidXQgdGhlIGBSdWxlc2Agc2VjdGlvbiBvZiBDRk5cbiAgICAvLyB0ZW1wbGF0ZXMgZG9lc24ndCBzZWVtIHRvIGJlIGFibGUgdG8gZXhwcmVzcyB0aGUgY29uZGl0aW9ucyB0aGF0IHdlIG5lZWRcbiAgICAvLyAoY2FuJ3QgdXNlIEZuOjpKb2luIG9yIHJlZmVyZW5jZSBDb25kaXRpb25zKSBzbyB3ZSBkbyBpdCBoZXJlIGluc3RlYWQuXG4gICAgY29uc3QgdHJ1c3RlZEFjY291bnRzID0gcGFyYW1zLnRydXN0ZWRBY2NvdW50cyA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHMpO1xuICAgIGluZm8oYFRydXN0ZWQgYWNjb3VudHMgZm9yIGRlcGxveW1lbnQ6ICR7dHJ1c3RlZEFjY291bnRzLmxlbmd0aCA+IDAgPyB0cnVzdGVkQWNjb3VudHMuam9pbignLCAnKSA6ICcobm9uZSknfWApO1xuXG4gICAgY29uc3QgdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwID0gcGFyYW1zLnRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cCA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHNGb3JMb29rdXApO1xuICAgIGluZm8oYFRydXN0ZWQgYWNjb3VudHMgZm9yIGxvb2t1cDogJHt0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAubGVuZ3RoID4gMCA/IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5qb2luKCcsICcpIDogJyhub25lKSd9YCk7XG5cbiAgICBjb25zdCBjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzID0gcGFyYW1zLmNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMgPz8gc3BsaXRDZm5BcnJheShjdXJyZW50LnBhcmFtZXRlcnMuQ2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyk7XG4gICAgaWYgKHRydXN0ZWRBY2NvdW50cy5sZW5ndGggPT09IDAgJiYgY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEZvciBzZWxmLXRydXN0IGl0J3Mgb2theSB0byBkZWZhdWx0IHRvIEFkbWluaXN0cmF0b3JBY2Nlc3MsIGFuZCBpdCBpbXByb3ZlcyB0aGUgdXNhYmlsaXR5IG9mIGJvb3RzdHJhcHBpbmcgYSBsb3QuXG4gICAgICAvL1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgbWFrZSB0aGUgaW1wbGljaXRseSBwb2xpY3kgYSBwaHlzaWNhbCBwYXJhbWV0ZXIuIFRoZSB0ZW1wbGF0ZSB3aWxsIGluZmVyIGl0IGluc3RlYWQsXG4gICAgICAvLyB3ZSBzaW1wbHkgZG8gdGhlIFVJIGFkdmVydGlzaW5nIHRoYXQgYmVoYXZpb3IgaGVyZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBESUQgbWFrZSBpdCBhbiBleHBsaWNpdCBwYXJhbWV0ZXIsIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHdoZXRoZXJcbiAgICAgIC8vIHdlIGluZmVycmVkIGl0IG9yIHdoZXRoZXIgdGhlIHVzZXIgdG9sZCB1cywgYW5kIHRoZSBzZXF1ZW5jZTpcbiAgICAgIC8vXG4gICAgICAvLyAkIGNkayBib290c3RyYXBcbiAgICAgIC8vICQgY2RrIGJvb3RzdHJhcCAtLXRydXN0IDEyMzRcbiAgICAgIC8vXG4gICAgICAvLyBXb3VsZCBsZWF2ZSBBZG1pbmlzdHJhdG9yQWNjZXNzIHBvbGljaWVzIHdpdGggYSB0cnVzdCByZWxhdGlvbnNoaXAsIHdpdGhvdXQgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgICAgLy8gYXBwcm92aW5nIHRoZSB0cnVzdCBwb2xpY3kuXG4gICAgICBjb25zdCBpbXBsaWNpdFBvbGljeSA9IGBhcm46JHtwYXJ0aXRpb259OmlhbTo6YXdzOnBvbGljeS9BZG1pbmlzdHJhdG9yQWNjZXNzYDtcbiAgICAgIHdhcm5pbmcoYFVzaW5nIGRlZmF1bHQgZXhlY3V0aW9uIHBvbGljeSBvZiAnJHtpbXBsaWNpdFBvbGljeX0nLiBQYXNzICctLWNsb3VkZm9ybWF0aW9uLWV4ZWN1dGlvbi1wb2xpY2llcycgdG8gY3VzdG9taXplLmApO1xuICAgIH0gZWxzZSBpZiAoY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgXFwnLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXNcXCcgd2hlbiB1c2luZyBcXCctLXRydXN0XFwnIHRvIHNwZWNpZnkgZGVwbG95bWVudCBwZXJtaXNzaW9ucy4gVHJ5IGEgbWFuYWdlZCBwb2xpY3kgb2YgdGhlIGZvcm0gXFwnYXJuOmF3czppYW06OmF3czpwb2xpY3kvPFBvbGljeU5hbWU+XFwnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1pbmQgcGVvcGxlIHdoYXQgdGhlIGN1cnJlbnQgc2V0dGluZ3MgYXJlXG4gICAgICBpbmZvKGBFeGVjdXRpb24gcG9saWNpZXM6ICR7Y2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIC8vICogSWYgYW4gQVJOIGlzIGdpdmVuLCB0aGF0IEFSTi4gT3RoZXJ3aXNlOlxuICAgIC8vICAgKiAnLScgaWYgY3VzdG9tZXJLZXkgPSBmYWxzZVxuICAgIC8vICAgKiAnJyBpZiBjdXN0b21lcktleSA9IHRydWVcbiAgICAvLyAgICogaWYgY3VzdG9tZXJLZXkgaXMgYWxzbyBub3QgZ2l2ZW5cbiAgICAvLyAgICAgKiB1bmRlZmluZWQgaWYgd2UgYWxyZWFkeSBoYWQgYSB2YWx1ZSBpbiBwbGFjZSAocmV1c2luZyB3aGF0IHdlIGhhZClcbiAgICAvLyAgICAgKiAnLScgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBkZXBsb3lpbmcgdGhpcyBzdGFjayAob3IgdXBncmFkaW5nIGZyb20gb2xkIHRvIG5ldyBib290c3RyYXApXG4gICAgY29uc3QgY3VycmVudEttc0tleUlkID0gY3VycmVudC5wYXJhbWV0ZXJzLkZpbGVBc3NldHNCdWNrZXRLbXNLZXlJZDtcbiAgICBjb25zdCBrbXNLZXlJZCA9IHBhcmFtcy5rbXNLZXlJZCA/P1xuICAgICAgICAocGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ID09PSB0cnVlID8gQ1JFQVRFX05FV19LRVkgOlxuICAgICAgICAgIHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSA9PT0gZmFsc2UgfHwgY3VycmVudEttc0tleUlkID09PSB1bmRlZmluZWQgPyBVU0VfQVdTX01BTkFHRURfS0VZIDogdW5kZWZpbmVkKTtcblxuICAgIC8qIEEgcGVybWlzc2lvbnMgYm91bmRhcnkgY2FuIGJlIHByb3ZpZGVkIHZpYTpcbiAgICAqICAgIC0gdGhlIGZsYWcgaW5kaWNhdGluZyB0aGUgZXhhbXBsZSBvbmUgc2hvdWxkIGJlIHVzZWRcbiAgICAqICAgIC0gdGhlIG5hbWUgaW5kaWNhdGluZyB0aGUgY3VzdG9tIHBlcm1pc3Npb25zIGJvdW5kYXJ5IHRvIGJlIHVzZWRcbiAgICAqIFJlLWJvb3RzdHJhcHBpbmcgd2lsbCBOT1QgYmUgYmxvY2tlZCBieSBlaXRoZXIgdGlnaHRlbmluZyBvciByZWxheGluZyB0aGUgcGVybWlzc2lvbnMnIGJvdW5kYXJ5LlxuICAgICovXG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25zQm91bmRhcnkgPSBjdXJyZW50LnBhcmFtZXRlcnMuSW5wdXRQZXJtaXNzaW9uc0JvdW5kYXJ5O1xuICAgIGNvbnN0IGlucHV0UG9saWN5TmFtZSA9IHBhcmFtcy5leGFtcGxlUGVybWlzc2lvbnNCb3VuZGFyeSA/IENES19CT09UU1RSQVBfUEVSTUlTU0lPTlNfQk9VTkRBUlkgOiBwYXJhbXMuY3VzdG9tUGVybWlzc2lvbnNCb3VuZGFyeTtcbiAgICBsZXQgcG9saWN5TmFtZTtcbiAgICBpZiAoaW5wdXRQb2xpY3lOYW1lKSB7XG4gICAgICAvLyBJZiB0aGUgZXhhbXBsZSBwb2xpY3kgaXMgbm90IGFscmVhZHkgaW4gcGxhY2UsIGl0IG11c3QgYmUgY3JlYXRlZC5cbiAgICAgIGNvbnN0IHNkayA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnZpcm9ubWVudCwgTW9kZS5Gb3JXcml0aW5nKSkuc2RrO1xuICAgICAgcG9saWN5TmFtZSA9IGF3YWl0IHRoaXMuZ2V0UG9saWN5TmFtZShlbnZpcm9ubWVudCwgc2RrLCBpbnB1dFBvbGljeU5hbWUsIHBhcnRpdGlvbiwgcGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5ICE9PSBwb2xpY3lOYW1lKSB7XG4gICAgICB3YXJuaW5nKGBTd2l0Y2hpbmcgZnJvbSAke2N1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5fSB0byAke3BvbGljeU5hbWV9IGFzIHBlcm1pc3Npb25zIGJvdW5kYXJ5YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQudXBkYXRlKFxuICAgICAgYm9vdHN0cmFwVGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIEZpbGVBc3NldHNCdWNrZXROYW1lOiBwYXJhbXMuYnVja2V0TmFtZSxcbiAgICAgICAgRmlsZUFzc2V0c0J1Y2tldEttc0tleUlkOiBrbXNLZXlJZCxcbiAgICAgICAgLy8gRW1wdHkgYXJyYXkgYmVjb21lcyBlbXB0eSBzdHJpbmdcbiAgICAgICAgVHJ1c3RlZEFjY291bnRzOiB0cnVzdGVkQWNjb3VudHMuam9pbignLCcpLFxuICAgICAgICBUcnVzdGVkQWNjb3VudHNGb3JMb29rdXA6IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5qb2luKCcsJyksXG4gICAgICAgIENsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXM6IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMuam9pbignLCcpLFxuICAgICAgICBRdWFsaWZpZXI6IHBhcmFtcy5xdWFsaWZpZXIsXG4gICAgICAgIFB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbjogcGFyYW1zLnB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbiB8fCBwYXJhbXMucHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uID09PSB1bmRlZmluZWQgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICBJbnB1dFBlcm1pc3Npb25zQm91bmRhcnk6IHBvbGljeU5hbWUsXG4gICAgICB9LCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogb3B0aW9ucy50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gY3VycmVudC50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0UG9saWN5TmFtZShcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrOiBJU0RLLFxuICAgIHBlcm1pc3Npb25zQm91bmRhcnk6IHN0cmluZyxcbiAgICBwYXJ0aXRpb246IHN0cmluZyxcbiAgICBwYXJhbXM6IEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzKTogUHJvbWlzZTxzdHJpbmc+IHtcblxuICAgIGlmIChwZXJtaXNzaW9uc0JvdW5kYXJ5ICE9PSBDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlUG9saWN5TmFtZShwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGVybWlzc2lvbnNCb3VuZGFyeSk7XG4gICAgfVxuICAgIC8vIGlmIG5vIFF1YWxpZmllciBpcyBzdXBwbGllZCwgcmVzb3J0IHRvIHRoZSBkZWZhdWx0IG9uZVxuICAgIGNvbnN0IGFybiA9IGF3YWl0IHRoaXMuZ2V0RXhhbXBsZVBlcm1pc3Npb25zQm91bmRhcnkocGFyYW1zLnF1YWxpZmllciA/PyAnaG5iNjU5ZmRzJywgcGFydGl0aW9uLCBlbnZpcm9ubWVudC5hY2NvdW50LCBzZGspO1xuICAgIGNvbnN0IHBvbGljeU5hbWUgPSBhcm4uc3BsaXQoJy8nKS5wb3AoKTtcbiAgICBpZiAoIXBvbGljeU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJldHJpZXZlIHRoZSBleGFtcGxlIHBlcm1pc3Npb24gYm91bmRhcnkhJyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocG9saWN5TmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldEV4YW1wbGVQZXJtaXNzaW9uc0JvdW5kYXJ5KHF1YWxpZmllcjogc3RyaW5nLCBwYXJ0aXRpb246IHN0cmluZywgYWNjb3VudDogc3RyaW5nLCBzZGs6IElTREspOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGlhbSA9IHNkay5pYW0oKTtcblxuICAgIGxldCBwb2xpY3lOYW1lID0gYGNkay0ke3F1YWxpZmllcn0tcGVybWlzc2lvbnMtYm91bmRhcnlgO1xuICAgIGNvbnN0IGFybiA9IGBhcm46JHtwYXJ0aXRpb259OmlhbTo6JHthY2NvdW50fTpwb2xpY3kvJHtwb2xpY3lOYW1lfWA7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IGdldFBvbGljeVJlc3AgPSBhd2FpdCBpYW0uZ2V0UG9saWN5KHsgUG9saWN5QXJuOiBhcm4gfSkucHJvbWlzZSgpO1xuICAgICAgaWYgKGdldFBvbGljeVJlc3AuUG9saWN5KSB7XG4gICAgICAgIHJldHVybiBhcm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0lBTS9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9HZXRQb2xpY3kuaHRtbCNBUElfR2V0UG9saWN5X0Vycm9yc1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ05vU3VjaEVudGl0eScpIHtcbiAgICAgICAgLy9ub29wLCBwcm9jZWVkIHdpdGggY3JlYXRpbmcgdGhlIHBvbGljeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwb2xpY3lEb2MgPSB7XG4gICAgICBWZXJzaW9uOiAnMjAxMi0xMC0xNycsXG4gICAgICBTdGF0ZW1lbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIEFjdGlvbjogWycqJ10sXG4gICAgICAgICAgUmVzb3VyY2U6ICcqJyxcbiAgICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICAgICAgU2lkOiAnRXhwbGljaXRBbGxvd0FsbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBDb25kaXRpb246IHtcbiAgICAgICAgICAgIFN0cmluZ0VxdWFsczoge1xuICAgICAgICAgICAgICAnaWFtOlBlcm1pc3Npb25zQm91bmRhcnknOiBgYXJuOiR7cGFydGl0aW9ufTppYW06OiR7YWNjb3VudH06cG9saWN5L2Nkay0ke3F1YWxpZmllcn0tcGVybWlzc2lvbnMtYm91bmRhcnlgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEFjdGlvbjogW1xuICAgICAgICAgICAgJ2lhbTpDcmVhdGVVc2VyJyxcbiAgICAgICAgICAgICdpYW06Q3JlYXRlUm9sZScsXG4gICAgICAgICAgICAnaWFtOlB1dFJvbGVQZXJtaXNzaW9uc0JvdW5kYXJ5JyxcbiAgICAgICAgICAgICdpYW06UHV0VXNlclBlcm1pc3Npb25zQm91bmRhcnknLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgUmVzb3VyY2U6ICcqJyxcbiAgICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICAgICAgU2lkOiAnRGVueUFjY2Vzc0lmUmVxdWlyZWRQZXJtQm91bmRhcnlJc05vdEJlaW5nQXBwbGllZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBBY3Rpb246IFtcbiAgICAgICAgICAgICdpYW06Q3JlYXRlUG9saWN5VmVyc2lvbicsXG4gICAgICAgICAgICAnaWFtOkRlbGV0ZVBvbGljeScsXG4gICAgICAgICAgICAnaWFtOkRlbGV0ZVBvbGljeVZlcnNpb24nLFxuICAgICAgICAgICAgJ2lhbTpTZXREZWZhdWx0UG9saWN5VmVyc2lvbicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBSZXNvdXJjZTogYGFybjoke3BhcnRpdGlvbn06aWFtOjoke2FjY291bnR9OnBvbGljeS9jZGstJHtxdWFsaWZpZXJ9LXBlcm1pc3Npb25zLWJvdW5kYXJ5YCxcbiAgICAgICAgICBFZmZlY3Q6ICdEZW55JyxcbiAgICAgICAgICBTaWQ6ICdEZW55UGVybUJvdW5kYXJ5SUFNUG9saWN5QWx0ZXJhdGlvbicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBBY3Rpb246IFtcbiAgICAgICAgICAgICdpYW06RGVsZXRlVXNlclBlcm1pc3Npb25zQm91bmRhcnknLFxuICAgICAgICAgICAgJ2lhbTpEZWxldGVSb2xlUGVybWlzc2lvbnNCb3VuZGFyeScsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBSZXNvdXJjZTogJyonLFxuICAgICAgICAgIEVmZmVjdDogJ0RlbnknLFxuICAgICAgICAgIFNpZDogJ0RlbnlSZW1vdmFsT2ZQZXJtQm91bmRhcnlGcm9tQW55VXNlck9yUm9sZScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIFBvbGljeU5hbWU6IHBvbGljeU5hbWUsXG4gICAgICBQb2xpY3lEb2N1bWVudDogSlNPTi5zdHJpbmdpZnkocG9saWN5RG9jKSxcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVBvbGljeVJlc3BvbnNlID0gYXdhaXQgaWFtLmNyZWF0ZVBvbGljeShyZXF1ZXN0KS5wcm9taXNlKCk7XG4gICAgaWYgKGNyZWF0ZVBvbGljeVJlc3BvbnNlLlBvbGljeT8uQXJuKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUG9saWN5UmVzcG9uc2UuUG9saWN5LkFybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmV0cmlldmUgdGhlIGV4YW1wbGUgcGVybWlzc2lvbiBib3VuZGFyeSAke2Fybn0hYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZVBvbGljeU5hbWUocGVybWlzc2lvbnNCb3VuZGFyeTogc3RyaW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0lBTS9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9DcmVhdGVQb2xpY3kuaHRtbFxuICAgIGNvbnN0IHJlZ2V4cDogUmVnRXhwID0gL1tcXHcrPSwuQC1dKy87XG4gICAgY29uc3QgbWF0Y2hlcyA9IHJlZ2V4cC5leGVjKHBlcm1pc3Npb25zQm91bmRhcnkpO1xuICAgIGlmICghKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPT09IDEgJiYgbWF0Y2hlc1swXSA9PT0gcGVybWlzc2lvbnNCb3VuZGFyeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBlcm1pc3Npb25zIGJvdW5kYXJ5IG5hbWUgJHtwZXJtaXNzaW9uc0JvdW5kYXJ5fSBkb2VzIG5vdCBtYXRjaCB0aGUgSUFNIGNvbnZlbnRpb25zLmApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3VzdG9tQm9vdHN0cmFwKFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gICAgb3B0aW9uczogQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG5cbiAgICAvLyBMb29rIGF0IHRoZSB0ZW1wbGF0ZSwgZGVjaWRlIHdoZXRoZXIgaXQncyBtb3N0IGxpa2VseSBhIGxlZ2FjeSBvciBtb2Rlcm4gYm9vdHN0cmFwXG4gICAgLy8gdGVtcGxhdGUsIGFuZCB1c2UgdGhlIHJpZ2h0IGJvb3RzdHJhcHBlciBmb3IgdGhhdC5cbiAgICBjb25zdCB2ZXJzaW9uID0gYm9vdHN0cmFwVmVyc2lvbkZyb21UZW1wbGF0ZShhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZSgpKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVnYWN5Qm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVybkJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFRlbXBsYXRlKHBhcmFtczogQm9vdHN0cmFwcGluZ1BhcmFtZXRlcnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgc3dpdGNoICh0aGlzLnNvdXJjZS5zb3VyY2UpIHtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiBsb2FkU3RydWN0dXJlZEZpbGUodGhpcy5zb3VyY2UudGVtcGxhdGVGaWxlKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gbG9hZFN0cnVjdHVyZWRGaWxlKHBhdGguam9pbihyb290RGlyKCksICdsaWInLCAnYXBpJywgJ2Jvb3RzdHJhcCcsICdib290c3RyYXAtdGVtcGxhdGUueWFtbCcpKTtcbiAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgIHJldHVybiBsZWdhY3lCb290c3RyYXBUZW1wbGF0ZShwYXJhbXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hZ2ljIHBhcmFtZXRlciB2YWx1ZSB0aGF0IHdpbGwgY2F1c2UgdGhlIGJvb3RzdHJhcC10ZW1wbGF0ZS55bWwgdG8gTk9UIGNyZWF0ZSBhIENNSyBidXQgdXNlIHRoZSBkZWZhdWx0IGtleVxuICovXG5jb25zdCBVU0VfQVdTX01BTkFHRURfS0VZID0gJ0FXU19NQU5BR0VEX0tFWSc7XG5cbi8qKlxuICogTWFnaWMgcGFyYW1ldGVyIHZhbHVlIHRoYXQgd2lsbCBjYXVzZSB0aGUgYm9vdHN0cmFwLXRlbXBsYXRlLnltbCB0byBjcmVhdGUgYSBDTUtcbiAqL1xuY29uc3QgQ1JFQVRFX05FV19LRVkgPSAnJztcbi8qKlxuICogUGFyYW1ldGVyIHZhbHVlIGluZGljYXRpbmcgdGhlIHVzZSBvZiB0aGUgZGVmYXVsdCwgQ0RLIHByb3ZpZGVkIHBlcm1pc3Npb25zIGJvdW5kYXJ5IGZvciBib290c3RyYXAtdGVtcGxhdGUueW1sXG4gKi9cbmNvbnN0IENES19CT09UU1RSQVBfUEVSTUlTU0lPTlNfQk9VTkRBUlkgPSAnQ0RLX0JPT1RTVFJBUF9QRVJNSVNTSU9OU19CT1VOREFSWSc7XG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXktbGlrZSBDbG91ZEZvcm1hdGlvbiBwYXJhbWV0ZXIgb24gLFxuICpcbiAqIEFuIGVtcHR5IHN0cmluZyBpcyB0aGUgZW1wdHkgYXJyYXkgKGluc3RlYWQgb2YgYFsnJ11gKS5cbiAqL1xuZnVuY3Rpb24gc3BsaXRDZm5BcnJheSh4czogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nW10ge1xuICBpZiAoeHMgPT09ICcnIHx8IHhzID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIFtdOyB9XG4gIHJldHVybiB4cy5zcGxpdCgnLCcpO1xufVxuIl19